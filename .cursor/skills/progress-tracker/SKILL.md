---
name: progress-tracker
description: 从项目排期中识别下一个开发任务，并验证声明的进度与实际代码状态是否一致。作为开发的"GPS"——告诉你当前位置和下一步该做什么。dev-workflow 管道的第 2 阶段。当用户说"检查进度"、"status"、"下一个任务"、"what's next"、"定位任务"时使用。
metadata:
  category: progress-tracking
  triggers: "status, what's next, find task, 检查进度, 下一个任务, 定位任务"
allowed-tools: Read Bash(python:*)
---

# 进度跟踪与任务发现 (Progress Tracker)

此技能从项目排期中识别**下一个开发任务**，并**验证**声明的进度是否与实际代码状态匹配。它作为开发的"GPS"——告诉你当前位置和下一步该做什么。

> **单一职责**: 定位 → 验证 → 确认

---

## 何时使用此技能

- 当你需要**查找下一个任务**时
- 当你想要**检查当前项目进度**时
- 当你怀疑**进度跟踪与实际代码不同步**时
- 作为 `dev-workflow` 管道的**第 2 阶段**
- 休息后**从正确的位置恢复开发**时

---

## 工作流程

```
┌──────────────────────────────────────────────────────────────────────────────┐
│  步骤 1              步骤 2                步骤 3              步骤 4        │
│  ────────            ────────              ────────            ────────      │
│  数据收集        →   进度验证          →   任务识别         →   用户确认     │
│  (Data Collection)   (Validation)          (Task Confirm)       (User OK)    │
│                          │                                                   │
│                          ▼                                                   │
│                     ⚠️ 不一致? → 上报用户 → 修复 DEV_SPEC                    │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## 步骤 1：数据收集

**目标**：收集声明的进度和实际代码状态的信息。

### 1.1 从规范中读取排期

1. 读取 `.cursor/skills/spec-sync/specs/06-schedule.md`（项目排期）
2. 解析任务表以识别：
   - 所有任务及其状态标记
   - 当前阶段（A、B、C、D、E、F）
   - 标记为已完成、进行中、未开始的任务

### 1.2 状态标记识别

| 标记 | 含义 | 状态 |
|------|------|------|
| `[ ]` | 未开始 | `NOT_STARTED` |
| `⬜` | 未开始 | `NOT_STARTED` |
| `[~]` | 进行中 | `IN_PROGRESS` |
| `🔄` | 进行中 | `IN_PROGRESS` |
| `[x]` | 已完成 | `COMPLETED` |
| `✅` | 已完成 | `COMPLETED` |
| `(进行中)` | 进行中 | `IN_PROGRESS` |
| `(已完成)` | 已完成 | `COMPLETED` |

### 1.3 构建任务列表

**输出结构**：
```
阶段 A: 基础架构搭建
  [x] A1: 项目骨架初始化
  [x] A2: 日志系统搭建
  [~] A3: 配置加载与校验  ← 当前（进行中）
  [ ] A4: MCP Server 框架
  
阶段 B: 核心模块开发
  [ ] B1: LLM 抽象接口与工厂
  [ ] B2: Embedding 服务封装
  ...
```

---

## 步骤 2：进度验证

**目标**：验证声明的进度与实际代码状态是否匹配。

### 2.1 识别验证目标

对于每个标记为 `COMPLETED` 或 `IN_PROGRESS` 的任务，识别预期的产物：

| 任务 | 预期产物 |
|------|----------|
| A1: 项目骨架 | `pyproject.toml`、`src/`、`tests/` 目录 |
| A2: 日志系统 | `src/core/logging.py`、日志配置 |
| A3: 配置加载 | `src/core/settings.py`、`settings.yaml` |
| B1: LLM工厂 | `src/llm/base.py`、`src/llm/factory.py` |

### 2.2 验证产物存在

对于每个预期产物：
1. 检查文件/目录是否存在
2. 对于代码文件，验证基本结构（导入正常、类已定义）
3. 检查相关测试是否存在并通过基本导入

**验证命令**：
```bash
# 检查文件是否存在
test -f src/core/settings.py && echo "EXISTS" || echo "MISSING"

# 检查模块导入
python -c "from src.core.settings import Settings" 2>&1
```

### 2.3 检测并处理不一致

**不一致类型**：

| 类型 | 描述 | 严重程度 |
|------|------|----------|
| `MISSING_FILE` | 任务标记为完成但文件不存在 | 高 |
| `IMPORT_ERROR` | 文件存在但有导入/语法错误 | 高 |
| `MISSING_TESTS` | 实现存在但没有测试 | 中 |
| `STALE_PROGRESS` | 任务标记为"进行中"已多个会话 | 中 |

**如果检测到任何不一致**，上报给用户：

```
────────────────────────────────────────────────────
⚠️ 检测到进度不一致
────────────────────────────────────────────────────

排期声明: 阶段 B1 - LLM 工厂（进行中）
实际状态: 阶段 A3 - 配置加载（未完成）

缺失项目:
  ❌ src/core/settings.py - 未找到
  ❌ tests/unit/test_config_loading.py - 未找到
  ⚠️ A2 日志测试未验证

────────────────────────────────────────────────────
选项:
────────────────────────────────────────────────────

1. 修复 DEV_SPEC.md 中的进度跟踪
   → 更新标记以反映实际状态
   → 重新运行 spec-sync
   → 重新开始任务发现
    
2. 确认之前的任务已完成
   → 代码可能在不同位置/分支
   → 提供解释并继续
    
3. 从实际进度继续
   → 跳过未完成的任务
   → 从代码实际位置开始

请选择一个选项 (1/2/3):
────────────────────────────────────────────────────
```

### 处理每个选项

**选项 1: 修复 DEV_SPEC.md**
1. 用户提供更正后的进度状态
2. 直接更新 `DEV_SPEC.md`（全局文件）
3. 运行 `python .cursor/skills/spec-sync/sync_spec.py`
4. **从本技能的步骤 1 重新开始**

**选项 2: 确认完成**
1. 用户解释代码在哪里
2. 在会话中记录解释
3. 带着用户确认继续到步骤 3

**选项 3: 从实际进度继续**
1. 根据代码状态识别实际当前任务
2. 覆盖排期声明的位置
3. 带着更正后的任务继续到步骤 3

---

## 步骤 3：任务识别

**目标**：清晰识别下一个要做的单一任务。

### 3.1 确定下一个任务

**优先级逻辑**：
1. 如果有任务是 `IN_PROGRESS` → 那就是当前任务
2. 否则，找到第一个 `NOT_STARTED` 任务 → 那就是下一个任务
3. 如果所有任务都完成 → 报告"所有任务已完成"

### 3.2 收集任务上下文

对于识别的任务，收集：
- **任务 ID**：例如 `A3`、`B1`
- **任务名称**：例如"配置加载与校验"
- **阶段**：例如"阶段 A: 基础架构搭建"
- **规范章节**：哪个章节文件包含实现细节
- **依赖项**：应该完成的前置任务

### 3.3 输出任务信息

```
────────────────────────────────────────────────────
✅ 当前任务已识别
────────────────────────────────────────────────────

阶段:     A - 基础架构搭建
任务 ID:  A3
名称:     配置加载与校验
状态:     IN_PROGRESS (🔄)

规范参考:
  排期: specs/06-schedule.md (第 XX 行)
  详情: specs/03-tech-stack.md 第 3.2 节

依赖项:
  ✅ A1: 项目骨架初始化
  ✅ A2: 日志系统搭建

验证: 进度已验证 ✓
────────────────────────────────────────────────────
```

---

## 步骤 4：用户确认

**目标**：在继续之前获得用户的明确确认。

### 4.1 请求确认

```
────────────────────────────────────────────────────
🎯 确认任务
────────────────────────────────────────────────────

准备开始:
  [A3] 配置加载与校验

选项:
  ✅ Confirm / 确认 - 继续此任务
  🔄 Override / 指定其他 - 指定不同的任务
  ❌ Cancel / 取消 - 停止并审查

你的选择:
────────────────────────────────────────────────────
```

### 4.2 处理用户响应

| 响应 | 操作 |
|------|------|
| Confirm / 确认 / Yes | 将任务信息返回给调用者（dev-workflow 第 3 阶段）|
| Override / 指定其他 | 询问任务 ID，验证存在，返回该任务 |
| Cancel / 取消 | 停止工作流，返回空闲状态 |

---

## 快捷命令

| 用户说 | 行为 |
|--------|------|
| "status" / "检查进度" | 步骤 1-3（报告当前状态，无需确认）|
| "what's next" / "下一个任务" | 步骤 1-3（识别下一个任务）|
| "find task" / "定位任务" | 完整工作流（步骤 1-4）|
| "validate" / "验证进度" | 仅步骤 1-2（验证报告）|
| "fix progress" / "修正进度" | 步骤 2.4 工作流（不一致处理）|

---

## 输出契约

当被 `dev-workflow` 调用时，此技能返回：

**状态类型**: `OK` | `MISMATCH` | `ALL_COMPLETE` | `CANCELLED`

**如果 status == OK**:

| 字段 | 示例值 |
|------|--------|
| Task ID | `A3` |
| Task Name | `配置加载与校验` |
| Phase | `A - 基础架构搭建` |
| Spec Schedule Reference | `specs/06-schedule.md` 第 142 行 |
| Spec Detail File | `specs/03-tech-stack.md` 第 3.2 节 |
| Dependencies Met | Yes/No |

**如果 status == MISMATCH**:
- 声明任务 vs 实际任务
- 缺失项目列表
- 需要用户选择：修复 DEV_SPEC / 确认 / 从实际进度继续

---

## 重要规则

1. **继续之前始终验证**：永远不要假设排期是准确的。始终检查实际代码状态。

2. **需要用户确认**：不要自动继续到实现。等待用户明确确认。

3. **单一任务焦点**：一次识别一个任务。不要批量识别多个任务。

4. **依赖项意识**：如果之前的任务看起来未完成则警告，但让用户决定如何继续。

5. **非破坏性**：此技能只读取和报告。它不修改代码或规范文件（除非用户在不一致处理中明确选择选项 1）。

6. **优雅降级**：如果规范文件丢失，回退到直接读取 `DEV_SPEC.md`。

---
